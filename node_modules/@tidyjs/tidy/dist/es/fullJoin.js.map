{"version":3,"file":"fullJoin.js","sources":["../../src/fullJoin.ts"],"sourcesContent":["import { Datum, TidyFn } from './types';\nimport { isMatch, makeByMap, autodetectByMap, JoinOptions } from './innerJoin';\nimport { O } from 'ts-toolbelt';\n\n/**\n * Performs a full join on two collections\n * @param itemsToJoin The rows/items to be appended to end of collection\n */\nexport function fullJoin<T extends Datum, JoinT extends Datum>(\n  itemsToJoin: JoinT[],\n  options?: JoinOptions<JoinT, T> | null | undefined\n): TidyFn<T, O.Merge<T, Partial<JoinT>>> {\n  const _fullJoin: TidyFn<T, O.Merge<T, Partial<JoinT>>> = (\n    items: T[]\n  ): O.Merge<T, Partial<JoinT>>[] => {\n    if (!itemsToJoin.length) return items as any;\n    if (!items.length) return itemsToJoin as any;\n\n    // convert by option in to a map from T key to JoinT key\n    const byMap =\n      options?.by == null\n        ? autodetectByMap(items, itemsToJoin)\n        : makeByMap(options.by);\n\n    // keep track of what has been matched\n    const matchMap = new Map();\n\n    // when we miss a join, we want to explicitly add in undefined\n    // so our rows all have the same keys. get those keys here.\n    const joinObjectKeys = Object.keys(itemsToJoin[0]);\n\n    const joined = items.flatMap((d: T) => {\n      const matches = itemsToJoin.filter((j: JoinT) => {\n        const matched = isMatch(d, j, byMap);\n        if (matched) {\n          matchMap.set(j, true);\n        }\n        return matched;\n      });\n\n      if (matches.length) {\n        return matches.map((j: JoinT) => ({ ...d, ...j }));\n      }\n\n      // add in missing keys explicitly as undefined without\n      // overriding existing values and while maintaining order\n      // of keys\n      const undefinedFill = Object.fromEntries(\n        joinObjectKeys\n          .filter((key) => d[key] == null)\n          .map((key) => [key, undefined])\n      );\n\n      return { ...d, ...undefinedFill };\n    });\n\n    // add in the ones we missed\n    if (matchMap.size < itemsToJoin.length) {\n      const leftEmptyObject = Object.fromEntries(\n        Object.keys(items[0]).map((key) => [key, undefined])\n      );\n      for (const item of itemsToJoin) {\n        if (!matchMap.has(item)) {\n          joined.push({ ...leftEmptyObject, ...item });\n        }\n      }\n    }\n\n    return joined;\n  };\n  return _fullJoin;\n}\n"],"names":[],"mappings":";;kBASE,aACA;AAEA,QAAM,YAAmD,CACvD;AAEA,QAAI,CAAC,YAAY;AAAQ,aAAO;AAChC,QAAI,CAAC,MAAM;AAAQ,aAAO;AAG1B,UAAM,QACJ,oCAAS,OAAM,OACX,gBAAgB,OAAO,eACvB,UAAU,QAAQ;AAGxB,UAAM,WAAW,IAAI;AAIrB,UAAM,iBAAiB,OAAO,KAAK,YAAY;AAE/C,UAAM,SAAS,MAAM,QAAQ,CAAC;AAC5B,YAAM,UAAU,YAAY,OAAO,CAAC;AAClC,cAAM,UAAU,QAAQ,GAAG,GAAG;AAC9B,YAAI;AACF,mBAAS,IAAI,GAAG;AAAA;AAElB,eAAO;AAAA;AAGT,UAAI,QAAQ;AACV,eAAO,QAAQ,IAAI,CAAC,WAAmB,MAAM;AAAA;AAM/C,YAAM,gBAAgB,OAAO,YAC3B,eACG,OAAO,CAAC,QAAQ,EAAE,QAAQ,MAC1B,IAAI,CAAC,QAAQ,CAAC,KAAK;AAGxB,aAAO,IAAK,MAAM;AAAA;AAIpB,QAAI,SAAS,OAAO,YAAY;AAC9B,YAAM,kBAAkB,OAAO,YAC7B,OAAO,KAAK,MAAM,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK;AAE3C,iBAAW,QAAQ;AACjB,YAAI,CAAC,SAAS,IAAI;AAChB,iBAAO,KAAK,IAAK,oBAAoB;AAAA;AAAA;AAAA;AAK3C,WAAO;AAAA;AAET,SAAO;AAAA;;;;"}