{"version":3,"file":"mutate.js","sources":["../../src/mutate.ts"],"sourcesContent":["import { TidyFn, NonFunctionValue, Key } from './types';\nimport { A, O } from 'ts-toolbelt';\n\ntype MutateSpecValue<T, O = any> =\n  | ((item: T, index: number, array: Iterable<T>) => O)\n  | NonFunctionValue;\nexport type MutateSpec<T> = Record<Key, MutateSpecValue<T>>;\nexport type ResolvedObj<Obj extends Record<Key, MutateSpecValue<any>>> = {\n  [K in keyof Obj]: Obj[K] extends (...args: any) => any\n    ? ReturnType<Obj[K]> extends any[]\n      ? ReturnType<Obj[K]>[number]\n      : ReturnType<Obj[K]>\n    : Obj[K];\n};\n\ntype Mutated<T extends object, MSpec extends MutateSpec<T>> = O.Merge<\n  ResolvedObj<MSpec>,\n  T\n>;\n\ntype Compute<T> = A.Compute<T>;\n\n/**\n * Mutates items, one item at a time. For mutating across multiple items,\n * use mutateWithSummary.\n * @param mutateSpec\n */\nexport function mutate<T extends object, MSpec extends MutateSpec<T>>(\n  mutateSpec: MSpec\n): TidyFn<T, Compute<Mutated<T, MSpec>>> {\n  type MutatedT = Mutated<T, MSpec>;\n  // use Compute for better intellisense (reveals all keys in obj)\n  const _mutate: TidyFn<T, Compute<MutatedT>> = (\n    items: T[]\n  ): Compute<MutatedT>[] => {\n    // create the base items to merge mutated values into\n    // note we start with the original array so when we pass it as the third argument\n    // to a mutate function, you get the values that have been changed so far\n    const mutatedItems: MutatedT[] = items.map((d) => ({ ...d })) as MutatedT[];\n\n    // we can update each item completely one at a time, since mutate doesn't\n    // support looking across items. Use mutateWithSummary for that.\n    let i = 0;\n    for (const mutatedItem of mutatedItems) {\n      for (const key in mutateSpec) {\n        // get the mutated value for this item (either run the fn or use the constant)\n        const mutateSpecValue = mutateSpec[key];\n        const mutatedResult =\n          typeof mutateSpecValue === 'function'\n            ? mutateSpecValue(mutatedItem as T, i, mutatedItems as T[])\n            : mutateSpecValue;\n\n        mutatedItem[key as any] = mutatedResult;\n      }\n\n      ++i;\n    }\n\n    return mutatedItems as Compute<MutatedT>[];\n  };\n\n  return _mutate;\n}\n"],"names":[],"mappings":"gBA4BE;AAIA,QAAM,UAAwC,CAC5C;AAKA,UAAM,eAA2B,MAAM,IAAI,CAAC,WAAY;AAIxD,QAAI,IAAI;AACR,eAAW,eAAe;AACxB,iBAAW,OAAO;AAEhB,cAAM,kBAAkB,WAAW;AACnC,cAAM,gBACJ,OAAO,oBAAoB,aACvB,gBAAgB,aAAkB,GAAG,gBACrC;AAEN,oBAAY,OAAc;AAAA;AAG5B,QAAE;AAAA;AAGJ,WAAO;AAAA;AAGT,SAAO;AAAA;;;;"}